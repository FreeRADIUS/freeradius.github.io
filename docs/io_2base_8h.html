<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>/home/runner/work/freeradius-server/freeradius-server/src/lib/io/base.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="freeradius.png"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_c85d3e3c5052e9ad9ce18c6863244a25.html">lib</a></li><li class="navelem"><a class="el" href="dir_65bc51589f8002bfcb72faf47ab41180.html">io</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">base.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Transport-specific functions.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="talloc_8h_source.html">talloc.h</a>&gt;</code><br />
<code>#include &lt;freeradius-devel/io/channel.h&gt;</code><br />
<code>#include &lt;freeradius-devel/server/request.h&gt;</code><br />
<code>#include &lt;freeradius-devel/util/socket.h&gt;</code><br />
<code>#include &lt;freeradius-devel/util/time.h&gt;</code><br />
</div><div class="textblock"><div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Include dependency graph for base.h:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="io_2base_8h__incl.svg" width="100%" height="473"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</div>
<p><a href="io_2base_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structfr__io__address__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io_2base_8h.html#structfr__io__address__t">fr_io_address_t</a></td></tr>
<tr class="separator:structfr__io__address__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structfr__io__stats__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io_2base_8h.html#structfr__io__stats__t">fr_io_stats_t</a></td></tr>
<tr class="separator:structfr__io__stats__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aeeb7d548e3044038290ca4ceb4380122"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="channel_8c.html#structfr__channel__s">fr_channel_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io_2base_8h.html#aeeb7d548e3044038290ca4ceb4380122">fr_channel_t</a></td></tr>
<tr class="separator:aeeb7d548e3044038290ca4ceb4380122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028d7872e08c0e2f616b6b816c34237e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="io_2base_8h.html#af2efe91d34428792526f7d60f726b65d">RADCLIENT</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io_2base_8h.html#a028d7872e08c0e2f616b6b816c34237e">fr_io_client_find_t</a>) (<a class="el" href="io_2base_8h.html#a95ccbd507a54a5f34b157b378029bf23">fr_listen_t</a> *li, <a class="el" href="inet_8h.html#structfr__ipaddr__t">fr_ipaddr_t</a> const *ipaddr, int <a class="el" href="radclient_8c.html#a8af48c772696ef8d6f851a97149bc96b">ipproto</a>)</td></tr>
<tr class="separator:a028d7872e08c0e2f616b6b816c34237e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad507248352491c9cc747fe2391358fd0"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io_2base_8h.html#ad507248352491c9cc747fe2391358fd0">fr_io_close_t</a>) (<a class="el" href="io_2base_8h.html#a95ccbd507a54a5f34b157b378029bf23">fr_listen_t</a> *li)</td></tr>
<tr class="memdesc:ad507248352491c9cc747fe2391358fd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle a close on the socket.  <a href="#ad507248352491c9cc747fe2391358fd0">More...</a><br /></td></tr>
<tr class="separator:ad507248352491c9cc747fe2391358fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d137935c03271af7c4b0e6bfe7f36ef"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io_2base_8h.html#a7d137935c03271af7c4b0e6bfe7f36ef">fr_io_connection_set_t</a>) (<a class="el" href="io_2base_8h.html#a95ccbd507a54a5f34b157b378029bf23">fr_listen_t</a> *li, <a class="el" href="io_2base_8h.html#structfr__io__address__t">fr_io_address_t</a> *connection)</td></tr>
<tr class="separator:a7d137935c03271af7c4b0e6bfe7f36ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07a2beabef6a3ddd5102391131f4c47"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io_2base_8h.html#ab07a2beabef6a3ddd5102391131f4c47">fr_io_data_inject_t</a>) (<a class="el" href="io_2base_8h.html#a95ccbd507a54a5f34b157b378029bf23">fr_listen_t</a> *li, uint8_t *<a class="el" href="acutest_8h.html#a1774127cd71a8c01a10b5afcf19f44e6">buffer</a>, size_t buffer_len, <a class="el" href="time_8h.html#ae3bbe82b46d7b09dbfc1caa6765ddbde">fr_time_t</a> recv_time)</td></tr>
<tr class="memdesc:ab07a2beabef6a3ddd5102391131f4c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject data into a socket.  <a href="#ab07a2beabef6a3ddd5102391131f4c47">More...</a><br /></td></tr>
<tr class="separator:ab07a2beabef6a3ddd5102391131f4c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a236ab86b081ab2785460a99296dd9666"><td class="memItemLeft" align="right" valign="top">typedef ssize_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io_2base_8h.html#a236ab86b081ab2785460a99296dd9666">fr_io_data_read_t</a>) (<a class="el" href="io_2base_8h.html#a95ccbd507a54a5f34b157b378029bf23">fr_listen_t</a> *li, void **packet_ctx, <a class="el" href="time_8h.html#ae3bbe82b46d7b09dbfc1caa6765ddbde">fr_time_t</a> *recv_time, uint8_t *<a class="el" href="acutest_8h.html#a1774127cd71a8c01a10b5afcf19f44e6">buffer</a>, size_t buffer_len, size_t *leftover, uint32_t *priority, bool *dup)</td></tr>
<tr class="memdesc:a236ab86b081ab2785460a99296dd9666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from a socket.  <a href="#a236ab86b081ab2785460a99296dd9666">More...</a><br /></td></tr>
<tr class="separator:a236ab86b081ab2785460a99296dd9666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a360546a038f7378f005c18840f92be1b"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io_2base_8h.html#a360546a038f7378f005c18840f92be1b">fr_io_data_vnode_t</a>) (<a class="el" href="io_2base_8h.html#a95ccbd507a54a5f34b157b378029bf23">fr_listen_t</a> *li, uint32_t fflags)</td></tr>
<tr class="memdesc:a360546a038f7378f005c18840f92be1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell the IO handler that a VNODE has changed.  <a href="#a360546a038f7378f005c18840f92be1b">More...</a><br /></td></tr>
<tr class="separator:a360546a038f7378f005c18840f92be1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3c45d14690efd5cfa439e09e2990c9"><td class="memItemLeft" align="right" valign="top">typedef ssize_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io_2base_8h.html#a5a3c45d14690efd5cfa439e09e2990c9">fr_io_data_write_t</a>) (<a class="el" href="io_2base_8h.html#a95ccbd507a54a5f34b157b378029bf23">fr_listen_t</a> *li, void *packet_ctx, <a class="el" href="time_8h.html#ae3bbe82b46d7b09dbfc1caa6765ddbde">fr_time_t</a> request_time, uint8_t *<a class="el" href="acutest_8h.html#a1774127cd71a8c01a10b5afcf19f44e6">buffer</a>, size_t buffer_len, size_t written)</td></tr>
<tr class="memdesc:a5a3c45d14690efd5cfa439e09e2990c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a socket.  <a href="#a5a3c45d14690efd5cfa439e09e2990c9">More...</a><br /></td></tr>
<tr class="separator:a5a3c45d14690efd5cfa439e09e2990c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580d47af77007e6009ca478ac20f7b0e"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io_2base_8h.html#a580d47af77007e6009ca478ac20f7b0e">fr_io_decode_t</a>) (void const *instance, <a class="el" href="radclient_8c.html#a2fc1b64f51f8225195d32592e6fe8fc5">request_t</a> *request, uint8_t *const <a class="el" href="ring__buffer__test_8c.html#a4b83b6e2cf0af27630a64dce8dd7717a">data</a>, size_t data_len)</td></tr>
<tr class="memdesc:a580d47af77007e6009ca478ac20f7b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a raw packet and convert it into a request.  <a href="#a580d47af77007e6009ca478ac20f7b0e">More...</a><br /></td></tr>
<tr class="separator:a580d47af77007e6009ca478ac20f7b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9403e58a9c5a4244daf04edb2f7ab0ac"><td class="memItemLeft" align="right" valign="top">typedef ssize_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io_2base_8h.html#a9403e58a9c5a4244daf04edb2f7ab0ac">fr_io_encode_t</a>) (void const *instance, <a class="el" href="radclient_8c.html#a2fc1b64f51f8225195d32592e6fe8fc5">request_t</a> *request, uint8_t *<a class="el" href="acutest_8h.html#a1774127cd71a8c01a10b5afcf19f44e6">buffer</a>, size_t buffer_len)</td></tr>
<tr class="memdesc:a9403e58a9c5a4244daf04edb2f7ab0ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode data from a request_t into a raw packet.  <a href="#a9403e58a9c5a4244daf04edb2f7ab0ac">More...</a><br /></td></tr>
<tr class="separator:a9403e58a9c5a4244daf04edb2f7ab0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83665394751eca5da67491dfde204cd8"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io_2base_8h.html#a83665394751eca5da67491dfde204cd8">fr_io_get_fd_t</a>) (<a class="el" href="io_2base_8h.html#a95ccbd507a54a5f34b157b378029bf23">fr_listen_t</a> const *li)</td></tr>
<tr class="memdesc:a83665394751eca5da67491dfde204cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a selectable file descriptor for this I/O path.  <a href="#a83665394751eca5da67491dfde204cd8">More...</a><br /></td></tr>
<tr class="separator:a83665394751eca5da67491dfde204cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93bffb11d9157d890379b310974bc24c"><td class="memItemLeft" align="right" valign="top">typedef size_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io_2base_8h.html#a93bffb11d9157d890379b310974bc24c">fr_io_nak_t</a>) (<a class="el" href="io_2base_8h.html#a95ccbd507a54a5f34b157b378029bf23">fr_listen_t</a> *li, void *packet_ctx, uint8_t *const packet, size_t packet_len, uint8_t *reply, size_t reply_len)</td></tr>
<tr class="memdesc:a93bffb11d9157d890379b310974bc24c"><td class="mdescLeft">&#160;</td><td class="mdescRight">NAK a packet.  <a href="#a93bffb11d9157d890379b310974bc24c">More...</a><br /></td></tr>
<tr class="separator:a93bffb11d9157d890379b310974bc24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c9c3d8c5c7c0897f09aefb2fde4482"><td class="memItemLeft" align="right" valign="top">typedef char const  *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io_2base_8h.html#a58c9c3d8c5c7c0897f09aefb2fde4482">fr_io_name_t</a>) (<a class="el" href="io_2base_8h.html#a95ccbd507a54a5f34b157b378029bf23">fr_listen_t</a> *li)</td></tr>
<tr class="separator:a58c9c3d8c5c7c0897f09aefb2fde4482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6108d27bdd5928253040ca2c7977f4a"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io_2base_8h.html#af6108d27bdd5928253040ca2c7977f4a">fr_io_network_get_t</a>) (void *instance, int *<a class="el" href="radclient_8c.html#a8af48c772696ef8d6f851a97149bc96b">ipproto</a>, bool *dynamic_clients, <a class="el" href="io_2base_8h.html#a790414dcfc82dd0a4abf43e97783d62e">fr_trie_t</a> const **trie)</td></tr>
<tr class="separator:af6108d27bdd5928253040ca2c7977f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06bc5661ccf26a84c3c2533850a4e9e6"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io_2base_8h.html#a06bc5661ccf26a84c3c2533850a4e9e6">fr_io_open_t</a>) (<a class="el" href="io_2base_8h.html#a95ccbd507a54a5f34b157b378029bf23">fr_listen_t</a> *li)</td></tr>
<tr class="memdesc:a06bc5661ccf26a84c3c2533850a4e9e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open an I/O path.  <a href="#a06bc5661ccf26a84c3c2533850a4e9e6">More...</a><br /></td></tr>
<tr class="separator:a06bc5661ccf26a84c3c2533850a4e9e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77091f007cd2e15998726d71113cea9c"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io_2base_8h.html#a77091f007cd2e15998726d71113cea9c">fr_io_set_fd_t</a>) (<a class="el" href="io_2base_8h.html#a95ccbd507a54a5f34b157b378029bf23">fr_listen_t</a> *li, int fd)</td></tr>
<tr class="memdesc:a77091f007cd2e15998726d71113cea9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a selectable file descriptor for this I/O path.  <a href="#a77091f007cd2e15998726d71113cea9c">More...</a><br /></td></tr>
<tr class="separator:a77091f007cd2e15998726d71113cea9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae086777e2dc2eb2d1b42622fd2764b65"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io_2base_8h.html#ae086777e2dc2eb2d1b42622fd2764b65">fr_io_signal_t</a>) (<a class="el" href="io_2base_8h.html#a95ccbd507a54a5f34b157b378029bf23">fr_listen_t</a> *li)</td></tr>
<tr class="memdesc:ae086777e2dc2eb2d1b42622fd2764b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle an error on the socket.  <a href="#ae086777e2dc2eb2d1b42622fd2764b65">More...</a><br /></td></tr>
<tr class="separator:ae086777e2dc2eb2d1b42622fd2764b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b5b00719df241e0ea7e143da8233caa"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io_2base_8h.html#a9b5b00719df241e0ea7e143da8233caa">fr_io_track_cmp_t</a>) (void const *instance, void *thread_instance, <a class="el" href="io_2base_8h.html#af2efe91d34428792526f7d60f726b65d">RADCLIENT</a> *client, void const *one, void const *two)</td></tr>
<tr class="memdesc:a9b5b00719df241e0ea7e143da8233caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two tracking structures for storing in a duplicate detection tree.  <a href="#a9b5b00719df241e0ea7e143da8233caa">More...</a><br /></td></tr>
<tr class="separator:a9b5b00719df241e0ea7e143da8233caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9d5624c9c883d18a541e7ae0deddca"><td class="memItemLeft" align="right" valign="top">typedef void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io_2base_8h.html#a8c9d5624c9c883d18a541e7ae0deddca">fr_io_track_create_t</a>) (TALLOC_CTX *ctx, uint8_t const *packet, size_t packet_len)</td></tr>
<tr class="memdesc:a8c9d5624c9c883d18a541e7ae0deddca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a raw packet to a tracking structure.  <a href="#a8c9d5624c9c883d18a541e7ae0deddca">More...</a><br /></td></tr>
<tr class="separator:a8c9d5624c9c883d18a541e7ae0deddca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ccbd507a54a5f34b157b378029bf23"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="io_2listen_8h.html#structfr__listen">fr_listen</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io_2base_8h.html#a95ccbd507a54a5f34b157b378029bf23">fr_listen_t</a></td></tr>
<tr class="separator:a95ccbd507a54a5f34b157b378029bf23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790414dcfc82dd0a4abf43e97783d62e"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="trie_8c.html#structfr__trie__s">fr_trie_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io_2base_8h.html#a790414dcfc82dd0a4abf43e97783d62e">fr_trie_t</a></td></tr>
<tr class="separator:a790414dcfc82dd0a4abf43e97783d62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2efe91d34428792526f7d60f726b65d"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="client_8h.html#structrad__client">rad_client</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io_2base_8h.html#af2efe91d34428792526f7d60f726b65d">RADCLIENT</a></td></tr>
<tr class="separator:af2efe91d34428792526f7d60f726b65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Transport-specific functions. </p>
<dl class="section rcs"><dt>Id</dt><dd>6d651d11155b904397927ed91ae33c41bcafa95c </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2016 Alan DeKok (<a href="#" onclick="location.href='mai'+'lto:'+'ala'+'nd'+'@fr'+'ee'+'rad'+'iu'+'s.o'+'rg'; return false;">aland<span style="display: none;">.nosp@m.</span>@fre<span style="display: none;">.nosp@m.</span>eradi<span style="display: none;">.nosp@m.</span>us.o<span style="display: none;">.nosp@m.</span>rg</a>) </dd></dl>

<p class="definition">Definition in file <a class="el" href="io_2base_8h_source.html">base.h</a>.</p>
</div><hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structfr__io__address__t" id="structfr__io__address__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structfr__io__address__t">&#9670;&nbsp;</a></span>fr_io_address_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct fr_io_address_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="io_2base_8h_source.html#l00333">333</a> of file <a class="el" href="io_2base_8h_source.html">base.h</a>.</p>
</div><div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for fr_io_address_t:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="structfr__io__address__t__coll__graph.svg" width="575" height="442"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a91d2e0f2c0851a741c02350b722c3279"></a><a class="el" href="io_2base_8h.html#af2efe91d34428792526f7d60f726b65d">RADCLIENT</a> const  *</td>
<td class="fieldname">
radclient</td>
<td class="fielddoc">
old-style client definition </td></tr>
<tr><td class="fieldtype">
<a id="a259351a0ae797fb195f31c2f6f5e5fcd"></a><a class="el" href="util_2socket_8h.html#structfr__socket__t">fr_socket_t</a></td>
<td class="fieldname">
socket</td>
<td class="fielddoc">
src/dst ip and port. </td></tr>
</table>

</div>
</div>
<a name="structfr__io__stats__t" id="structfr__io__stats__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structfr__io__stats__t">&#9670;&nbsp;</a></span>fr_io_stats_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct fr_io_stats_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="io_2base_8h_source.html#l00042">42</a> of file <a class="el" href="io_2base_8h_source.html">base.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="aa46653049063328a7be71dd4122bea7b"></a>uint64_t</td>
<td class="fieldname">
dropped</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a8899353e86340dbf00b7729748c1cd7e"></a>uint64_t</td>
<td class="fieldname">
dup</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="af5b08efa94c104122b92aa3831ceb994"></a>uint64_t</td>
<td class="fieldname">
in</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a4c382c80354675862cb26ae651120088"></a>uint64_t</td>
<td class="fieldname">
out</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="aeeb7d548e3044038290ca4ceb4380122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeb7d548e3044038290ca4ceb4380122">&#9670;&nbsp;</a></span>fr_channel_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="channel_8c.html#structfr__channel__s">fr_channel_s</a> <a class="el" href="io_2base_8h.html#aeeb7d548e3044038290ca4ceb4380122">fr_channel_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="io_2base_8h_source.html#l00050">50</a> of file <a class="el" href="io_2base_8h_source.html">base.h</a>.</p>

</div>
</div>
<a id="a028d7872e08c0e2f616b6b816c34237e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028d7872e08c0e2f616b6b816c34237e">&#9670;&nbsp;</a></span>fr_io_client_find_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="io_2base_8h.html#af2efe91d34428792526f7d60f726b65d">RADCLIENT</a>*(* fr_io_client_find_t) (<a class="el" href="io_2base_8h.html#a95ccbd507a54a5f34b157b378029bf23">fr_listen_t</a> *li, <a class="el" href="inet_8h.html#structfr__ipaddr__t">fr_ipaddr_t</a> const *ipaddr, int <a class="el" href="radclient_8c.html#a8af48c772696ef8d6f851a97149bc96b">ipproto</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="io_2base_8h_source.html#l00343">343</a> of file <a class="el" href="io_2base_8h_source.html">base.h</a>.</p>

</div>
</div>
<a id="ad507248352491c9cc747fe2391358fd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad507248352491c9cc747fe2391358fd0">&#9670;&nbsp;</a></span>fr_io_close_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* fr_io_close_t) (<a class="el" href="io_2base_8h.html#a95ccbd507a54a5f34b157b378029bf23">fr_listen_t</a> *li)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle a close on the socket. </p>
<p>In general, the only thing to do on errors is to close the transport. But on error, the "error" function will be called before "close". On normal finish, the "close" function will be called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">li</td><td>the listener for this socket </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>&lt;0 on error </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="io_2base_8h_source.html#l00328">328</a> of file <a class="el" href="io_2base_8h_source.html">base.h</a>.</p>

</div>
</div>
<a id="a7d137935c03271af7c4b0e6bfe7f36ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d137935c03271af7c4b0e6bfe7f36ef">&#9670;&nbsp;</a></span>fr_io_connection_set_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* fr_io_connection_set_t) (<a class="el" href="io_2base_8h.html#a95ccbd507a54a5f34b157b378029bf23">fr_listen_t</a> *li, <a class="el" href="io_2base_8h.html#structfr__io__address__t">fr_io_address_t</a> *connection)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="io_2base_8h_source.html#l00339">339</a> of file <a class="el" href="io_2base_8h_source.html">base.h</a>.</p>

</div>
</div>
<a id="ab07a2beabef6a3ddd5102391131f4c47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab07a2beabef6a3ddd5102391131f4c47">&#9670;&nbsp;</a></span>fr_io_data_inject_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* fr_io_data_inject_t) (<a class="el" href="io_2base_8h.html#a95ccbd507a54a5f34b157b378029bf23">fr_listen_t</a> *li, uint8_t *<a class="el" href="acutest_8h.html#a1774127cd71a8c01a10b5afcf19f44e6">buffer</a>, size_t buffer_len, <a class="el" href="time_8h.html#ae3bbe82b46d7b09dbfc1caa6765ddbde">fr_time_t</a> recv_time)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inject data into a socket. </p>
<p>This function allows callers to inject data into a socket, just as if the data was read from a socket.</p>
<p>Note that this function is NOT an analog to fr_io_data_read_t. That is, the called function MUST copy the packet pointer into an internal list, so that subsequent calls to read() will return this packet.</p>
<p>The network side ensures that the packet buffer remains available to the called function for the duration of an inject() and read() call. i.e. the packet contents do NOT have to be saved, and the code can instead save the pointer to the buffer.</p>
<p>However, this buffer MUST be immediately returned on a subsequent call to read(). If it is not returned, the memory is still freed, and the pointer becomes invalid. Subsequent access to the buffer will result in crashes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">li</td><td>the listener for this socket </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the buffer where the raw packet to be injected </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_len</td><td>the length of the buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">recv_time</td><td>when the packet was received </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>&lt;0 on error</li>
<li>0 on success </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="io_2base_8h_source.html#l00252">252</a> of file <a class="el" href="io_2base_8h_source.html">base.h</a>.</p>

</div>
</div>
<a id="a236ab86b081ab2785460a99296dd9666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a236ab86b081ab2785460a99296dd9666">&#9670;&nbsp;</a></span>fr_io_data_read_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ssize_t(* fr_io_data_read_t) (<a class="el" href="io_2base_8h.html#a95ccbd507a54a5f34b157b378029bf23">fr_listen_t</a> *li, void **packet_ctx, <a class="el" href="time_8h.html#ae3bbe82b46d7b09dbfc1caa6765ddbde">fr_time_t</a> *recv_time, uint8_t *<a class="el" href="acutest_8h.html#a1774127cd71a8c01a10b5afcf19f44e6">buffer</a>, size_t buffer_len, size_t *leftover, uint32_t *priority, bool *dup)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read from a socket. </p>
<p>The network side guarantees that the read routine can leave partial data in the buffer. That data will be there on the next call to read. However, the data MAY have moved, so please do not keep a pointer to 'buffer' around.</p>
<p>datagram sockets should always set '*leftover = 0'.</p>
<p>stream sockets can read one packet, and set '*leftover' to how many bytes are left in the buffer. The read routine will be called again, with a (possibly new) buffer, but with 'leftover' bytes left in the buffer. The value in 'leftover'' will be the same as from the previous call, so the reader does not need to track it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">li</td><td>the listener for this socket </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">packet_ctx</td><td>Where to write a newly allocated packet_ctx struct containing request specific data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recv_time</td><td>A pointer to a time when the packet was received </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>the buffer where the raw packet will be written to (or read from) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_len</td><td>the length of the buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">leftover</td><td>bytes left in the buffer after reading a full packet. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">priority</td><td>priority of this packet (0 = low, 65535 = high) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dup</td><td>is it dup or new </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>&lt;0 on error</li>
<li>&gt;=0 length of the data read or written. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="io_2base_8h_source.html#l00179">179</a> of file <a class="el" href="io_2base_8h_source.html">base.h</a>.</p>

</div>
</div>
<a id="a360546a038f7378f005c18840f92be1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a360546a038f7378f005c18840f92be1b">&#9670;&nbsp;</a></span>fr_io_data_vnode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* fr_io_data_vnode_t) (<a class="el" href="io_2base_8h.html#a95ccbd507a54a5f34b157b378029bf23">fr_listen_t</a> *li, uint32_t fflags)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tell the IO handler that a VNODE has changed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">li</td><td>the listener for this socket </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fflags</td><td>from kevent. Usually just NOTE_EXEND </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="io_2base_8h_source.html#l00259">259</a> of file <a class="el" href="io_2base_8h_source.html">base.h</a>.</p>

</div>
</div>
<a id="a5a3c45d14690efd5cfa439e09e2990c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a3c45d14690efd5cfa439e09e2990c9">&#9670;&nbsp;</a></span>fr_io_data_write_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ssize_t(* fr_io_data_write_t) (<a class="el" href="io_2base_8h.html#a95ccbd507a54a5f34b157b378029bf23">fr_listen_t</a> *li, void *packet_ctx, <a class="el" href="time_8h.html#ae3bbe82b46d7b09dbfc1caa6765ddbde">fr_time_t</a> request_time, uint8_t *<a class="el" href="acutest_8h.html#a1774127cd71a8c01a10b5afcf19f44e6">buffer</a>, size_t buffer_len, size_t written)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a socket. </p>
<p>If the socket is a datagram socket, then the function can read or write directly into the buffer. Stream sockets are a bit more complicated.</p>
<p>A stream reader can read data into the buffer, and be guaranteed that the data will not change in between subsequent calls to the read routine.</p>
<p>A stream writer MUST be prepared for the caller to delete the data immediately after calling the write routine. This means that if the socket is not ready, the writer MUST copy the data to an internal buffer, usually in instance. It MUST then have a write callback on the socket, which is called when the socket is ready for writing. That callback can then write the internal buffer to the socket.</p>
<p>i.e. this write() function is a way for the network thread to write packets to the transport context. The data may or may not go out to the network right away.</p>
<p>If the write function does a partial write, it should return a value smaller than buffer_len to indicate this. The network functions will then pass that value to a subsequent write call, in the "written" argument.</p>
<p>The reason for this odd API is that read/write should be writing <em>packets</em>, not raw streams of bytes. This API allows the "buffer" parameter to always contain a full packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">li</td><td>the listener for this socket </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">packet_ctx</td><td>Request specific data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">request_time</td><td>when the original request was received </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>the buffer where the raw packet will be written from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_len</td><td>the length of the buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">written</td><td>total number of bytes written in previous calls for this packet. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>&lt;0 on error</li>
<li>&gt;=0 length of the data read or written. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="io_2base_8h_source.html#l00221">221</a> of file <a class="el" href="io_2base_8h_source.html">base.h</a>.</p>

</div>
</div>
<a id="a580d47af77007e6009ca478ac20f7b0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a580d47af77007e6009ca478ac20f7b0e">&#9670;&nbsp;</a></span>fr_io_decode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* fr_io_decode_t) (void const *instance, <a class="el" href="radclient_8c.html#a2fc1b64f51f8225195d32592e6fe8fc5">request_t</a> *request, uint8_t *const <a class="el" href="ring__buffer__test_8c.html#a4b83b6e2cf0af27630a64dce8dd7717a">data</a>, size_t data_len)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a raw packet and convert it into a request. </p>
<p>This function is the opposite of fr_io_encode_t.</p>
<p>The "decode" function is ONLY for decoding data. It should be aware of the protocol (e.g. RADIUS), but it MUST NOT know anything about the underlying network transport (e.g. UDP), and it MUST NOT know anything about how the data will be used (e.g. authorize, authenticate, etc. for Access-Request)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instance</td><td>of the <a class="el" href="application_8h.html#structfr__app__t" title="Describes a new application (protocol) ">fr_app_t</a> or <a class="el" href="app__io_8h.html#structfr__app__io__t" title="Public structure describing an I/O path for a protocol. ">fr_app_io_t</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>the raw packet data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_len</td><td>the length of the raw data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>where the decoded VPs should be placed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>&lt;0 on error</li>
<li>0 on success </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="io_2base_8h_source.html#l00104">104</a> of file <a class="el" href="io_2base_8h_source.html">base.h</a>.</p>

</div>
</div>
<a id="a9403e58a9c5a4244daf04edb2f7ab0ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9403e58a9c5a4244daf04edb2f7ab0ac">&#9670;&nbsp;</a></span>fr_io_encode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ssize_t(* fr_io_encode_t) (void const *instance, <a class="el" href="radclient_8c.html#a2fc1b64f51f8225195d32592e6fe8fc5">request_t</a> *request, uint8_t *<a class="el" href="acutest_8h.html#a1774127cd71a8c01a10b5afcf19f44e6">buffer</a>, size_t buffer_len)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode data from a request_t into a raw packet. </p>
<p>This function is the opposite of fr_io_decode_t.</p>
<p>The "encode" function is ONLY for encoding data. It should be aware of the protocol (e.g. RADIUS), but it MUST NOT know anything about the underlying network transport (e.g. UDP), and it MUST NOT know anything about how the data will be used (e.g. reject delay on Access-Reject)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instance</td><td>of the <a class="el" href="application_8h.html#structfr__app__t" title="Describes a new application (protocol) ">fr_app_t</a> or <a class="el" href="app__io_8h.html#structfr__app__io__t" title="Public structure describing an I/O path for a protocol. ">fr_app_io_t</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>request where the VPs to be encoded are located </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>the buffer where the raw packet will be written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_len</td><td>the length of the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>&lt;0 on error</li>
<li>&gt;=0 length of the encoded data in the buffer, will be &lt;=buffer_len </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="io_2base_8h_source.html#l00124">124</a> of file <a class="el" href="io_2base_8h_source.html">base.h</a>.</p>

</div>
</div>
<a id="a83665394751eca5da67491dfde204cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83665394751eca5da67491dfde204cd8">&#9670;&nbsp;</a></span>fr_io_get_fd_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* fr_io_get_fd_t) (<a class="el" href="io_2base_8h.html#a95ccbd507a54a5f34b157b378029bf23">fr_listen_t</a> const *li)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a selectable file descriptor for this I/O path. </p>
<p>Return the file descriptor associated with this I/O path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">li</td><td>the listener for this socket </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="io_2base_8h_source.html#l00076">76</a> of file <a class="el" href="io_2base_8h_source.html">base.h</a>.</p>

</div>
</div>
<a id="a93bffb11d9157d890379b310974bc24c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93bffb11d9157d890379b310974bc24c">&#9670;&nbsp;</a></span>fr_io_nak_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef size_t(* fr_io_nak_t) (<a class="el" href="io_2base_8h.html#a95ccbd507a54a5f34b157b378029bf23">fr_listen_t</a> *li, void *packet_ctx, uint8_t *const packet, size_t packet_len, uint8_t *reply, size_t reply_len)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>NAK a packet. </p>
<p>When a worker receives a packet, it sometimes is unable to process that request. In order for the channels to work correctly, every request MUST be met with a response. This function allows a worker to NAK a request, but NOT send a response packet on the network.</p>
<p>This function MUST NOT fail. It must always return some data.</p>
<p>When the NAK packet is received by the network side, the transport portion of the network side MUST be able to recognize the NAK and take the appropriate action. e.g. for RADIUS, mark a request as "do not respond", even if duplicates come in.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">li</td><td>the listener for this socket </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">packet_ctx</td><td>the packet_ctx struct containing request specific data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">packet</td><td>the packet to NAK </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">packet_len</td><td>length of the packet to NAK </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reply</td><td>the NAK reply </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reply_len</td><td>length of the buffer where the reply should be placed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length of the data in the reply buffer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="io_2base_8h_source.html#l00149">149</a> of file <a class="el" href="io_2base_8h_source.html">base.h</a>.</p>

</div>
</div>
<a id="a58c9c3d8c5c7c0897f09aefb2fde4482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58c9c3d8c5c7c0897f09aefb2fde4482">&#9670;&nbsp;</a></span>fr_io_name_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef char const*(* fr_io_name_t) (<a class="el" href="io_2base_8h.html#a95ccbd507a54a5f34b157b378029bf23">fr_listen_t</a> *li)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="io_2base_8h_source.html#l00347">347</a> of file <a class="el" href="io_2base_8h_source.html">base.h</a>.</p>

</div>
</div>
<a id="af6108d27bdd5928253040ca2c7977f4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6108d27bdd5928253040ca2c7977f4a">&#9670;&nbsp;</a></span>fr_io_network_get_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* fr_io_network_get_t) (void *instance, int *<a class="el" href="radclient_8c.html#a8af48c772696ef8d6f851a97149bc96b">ipproto</a>, bool *dynamic_clients, <a class="el" href="io_2base_8h.html#a790414dcfc82dd0a4abf43e97783d62e">fr_trie_t</a> const **trie)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="io_2base_8h_source.html#l00345">345</a> of file <a class="el" href="io_2base_8h_source.html">base.h</a>.</p>

</div>
</div>
<a id="a06bc5661ccf26a84c3c2533850a4e9e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06bc5661ccf26a84c3c2533850a4e9e6">&#9670;&nbsp;</a></span>fr_io_open_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* fr_io_open_t) (<a class="el" href="io_2base_8h.html#a95ccbd507a54a5f34b157b378029bf23">fr_listen_t</a> *li)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open an I/O path. </p>
<p>Open a socket, file, or anything else that can be referenced by a file descriptor.</p>
<p>The file descriptor should be made available to the event loop via the selectable_fd callback. It will only be used to determine if the socket is readable/writable/has errored.</p>
<p>No data will be read from or written to the fd, except by the io_data callbacks here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">li</td><td>the listener for this socket </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>&lt;0 on error </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="io_2base_8h_source.html#l00068">68</a> of file <a class="el" href="io_2base_8h_source.html">base.h</a>.</p>

</div>
</div>
<a id="a77091f007cd2e15998726d71113cea9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77091f007cd2e15998726d71113cea9c">&#9670;&nbsp;</a></span>fr_io_set_fd_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* fr_io_set_fd_t) (<a class="el" href="io_2base_8h.html#a95ccbd507a54a5f34b157b378029bf23">fr_listen_t</a> *li, int fd)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a selectable file descriptor for this I/O path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">li</td><td>the listener for this socket </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>the FD to set </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="io_2base_8h_source.html#l00084">84</a> of file <a class="el" href="io_2base_8h_source.html">base.h</a>.</p>

</div>
</div>
<a id="ae086777e2dc2eb2d1b42622fd2764b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae086777e2dc2eb2d1b42622fd2764b65">&#9670;&nbsp;</a></span>fr_io_signal_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* fr_io_signal_t) (<a class="el" href="io_2base_8h.html#a95ccbd507a54a5f34b157b378029bf23">fr_listen_t</a> *li)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle an error on the socket. </p>
<p>In general, the only thing to do on errors is to close the transport. But on error, the "error" function will be called before "close". On normal finish, the "close" function will be called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">li</td><td>the listener for this socket </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>&lt;0 on error </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="io_2base_8h_source.html#l00314">314</a> of file <a class="el" href="io_2base_8h_source.html">base.h</a>.</p>

</div>
</div>
<a id="a9b5b00719df241e0ea7e143da8233caa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b5b00719df241e0ea7e143da8233caa">&#9670;&nbsp;</a></span>fr_io_track_cmp_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* fr_io_track_cmp_t) (void const *instance, void *thread_instance, <a class="el" href="io_2base_8h.html#af2efe91d34428792526f7d60f726b65d">RADCLIENT</a> *client, void const *one, void const *two)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two tracking structures for storing in a duplicate detection tree. </p>
<p>We presume that the packets are well formed.</p>
<p>The comparison should be stable. i.e. compare the packets a field at a time. If the field is different, return the result from that field.</p>
<p>The comparison order of the fields should be "very different" to "much the same". The packets are put into an rbtree, so having a large fanout at the top is useful.</p>
<p>Note that this function should not check if the packets are completely identical. Instead, it checks particular fields in the packet so that we can distinguish packets without checking the entire packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instance</td><td>the context for this function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thread_instance</td><td>the thread instance for this function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">client</td><td>the client associated with this packet </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">one</td><td>packet tracking structure one </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">two</td><td>packet tracking structure two </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>&lt;0 on packet one "smaller" than packet two</li>
<li>&gt;0 on packet two "larger" than packet one</li>
<li>=0 on the two packets being identical </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="io_2base_8h_source.html#l00300">300</a> of file <a class="el" href="io_2base_8h_source.html">base.h</a>.</p>

</div>
</div>
<a id="a8c9d5624c9c883d18a541e7ae0deddca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9d5624c9c883d18a541e7ae0deddca">&#9670;&nbsp;</a></span>fr_io_track_create_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void*(* fr_io_track_create_t) (TALLOC_CTX *ctx, uint8_t const *packet, size_t packet_len)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a raw packet to a tracking structure. </p>
<p>For passing to fr_io_track_cmp_t</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>The parent talloc ctx </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">packet</td><td>The packet being summarized </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">packet_len</td><td>Length of the packet being summarized </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>NULL on error</li>
<li>!NULL the packet tracking structure </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="io_2base_8h_source.html#l00272">272</a> of file <a class="el" href="io_2base_8h_source.html">base.h</a>.</p>

</div>
</div>
<a id="a95ccbd507a54a5f34b157b378029bf23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95ccbd507a54a5f34b157b378029bf23">&#9670;&nbsp;</a></span>fr_listen_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="io_2listen_8h.html#structfr__listen">fr_listen</a> <a class="el" href="io_2base_8h.html#a95ccbd507a54a5f34b157b378029bf23">fr_listen_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="io_2base_8h_source.html#l00039">39</a> of file <a class="el" href="io_2base_8h_source.html">base.h</a>.</p>

</div>
</div>
<a id="a790414dcfc82dd0a4abf43e97783d62e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a790414dcfc82dd0a4abf43e97783d62e">&#9670;&nbsp;</a></span>fr_trie_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="trie_8c.html#structfr__trie__s">fr_trie_s</a> <a class="el" href="io_2base_8h.html#a790414dcfc82dd0a4abf43e97783d62e">fr_trie_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="io_2base_8h_source.html#l00040">40</a> of file <a class="el" href="io_2base_8h_source.html">base.h</a>.</p>

</div>
</div>
<a id="af2efe91d34428792526f7d60f726b65d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2efe91d34428792526f7d60f726b65d">&#9670;&nbsp;</a></span>RADCLIENT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="client_8h.html#structrad__client">rad_client</a> <a class="el" href="io_2base_8h.html#af2efe91d34428792526f7d60f726b65d">RADCLIENT</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="io_2base_8h_source.html#l00341">341</a> of file <a class="el" href="io_2base_8h_source.html">base.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Nov 15 2020 16:11:00 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
